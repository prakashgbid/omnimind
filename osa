#!/usr/bin/env python3
"""
OSA - OmniMind Super Agent CLI
Professional command-line interface similar to Claude Code but with enhanced capabilities.
"""

import os
import sys
import asyncio
import argparse
import json
import readline
import atexit
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any, List
import subprocess
import signal

# Add the src directory to path
SCRIPT_DIR = Path(__file__).resolve().parent
sys.path.insert(0, str(SCRIPT_DIR / "src"))

from core.osa_minimal import OSACompleteFinal
from core.logger import setup_logger

# Rich terminal UI (optional, fallback to basic if not available)
try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.markdown import Markdown
    from rich.syntax import Syntax
    from rich.prompt import Prompt
    from rich.live import Live
    from rich.layout import Layout
    from rich.table import Table
    from rich import print as rprint
    RICH_AVAILABLE = True
    console = Console()
except ImportError:
    RICH_AVAILABLE = False
    console = None

# Global OSA instance
osa_instance = None
session_history = []

# Configuration
CONFIG_DIR = Path.home() / ".osa"
CONFIG_FILE = CONFIG_DIR / "config.json"
HISTORY_FILE = CONFIG_DIR / "history.txt"
SESSION_FILE = CONFIG_DIR / "session.json"

class OSATerminal:
    """OSA Terminal Interface - Claude Code style."""
    
    def __init__(self):
        self.osa = None
        self.config = self.load_config()
        self.setup_readline()
        self.running = True
        self.context_mode = "general"  # general, code, thinking, learning
        self.session_start = datetime.now()
        self.command_count = 0
        self.current_project = Path.cwd()
        
        # Setup signal handlers
        signal.signal(signal.SIGINT, self.handle_interrupt)
        
    def load_config(self) -> Dict[str, Any]:
        """Load or create configuration."""
        CONFIG_DIR.mkdir(exist_ok=True)
        
        default_config = {
            "model": "llama3.2:3b",
            "theme": "dark",
            "verbose": False,
            "auto_save": True,
            "enable_thinking": True,
            "enable_learning": True,
            "max_history": 1000,
            "shortcuts": {
                "/help": "Show help",
                "/exit": "Exit OSA",
                "/clear": "Clear screen",
                "/history": "Show history",
                "/think": "Enter thinking mode",
                "/code": "Enter code mode",
                "/save": "Save session",
                "/status": "Show status",
                "/model": "Change model",
                "/project": "Set project context"
            }
        }
        
        if CONFIG_FILE.exists():
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                # Merge with defaults
                for key, value in default_config.items():
                    if key not in config:
                        config[key] = value
                return config
        else:
            with open(CONFIG_FILE, 'w') as f:
                json.dump(default_config, f, indent=2)
            return default_config
    
    def save_config(self):
        """Save configuration."""
        with open(CONFIG_FILE, 'w') as f:
            json.dump(self.config, f, indent=2)
    
    def setup_readline(self):
        """Setup readline for better input handling."""
        # Enable tab completion
        readline.parse_and_bind("tab: complete")
        
        # Load history with error handling
        if HISTORY_FILE.exists():
            try:
                readline.read_history_file(str(HISTORY_FILE))
            except (PermissionError, IOError) as e:
                # Create new history file if permission error
                print(f"Note: Could not load history: {e}")
                try:
                    HISTORY_FILE.touch()
                    HISTORY_FILE.chmod(0o600)
                except:
                    pass
        else:
            # Create history file if it doesn't exist
            try:
                HISTORY_FILE.parent.mkdir(parents=True, exist_ok=True)
                HISTORY_FILE.touch()
                HISTORY_FILE.chmod(0o600)
            except:
                pass
        
        # Set history size
        readline.set_history_length(self.config.get("max_history", 1000))
        
        # Save history on exit
        atexit.register(self.save_history)
    
    def save_history(self):
        """Save command history."""
        try:
            readline.write_history_file(str(HISTORY_FILE))
        except (PermissionError, IOError):
            # Silently fail if we can't write history
            pass
    
    def handle_interrupt(self, signum, frame):
        """Handle Ctrl+C gracefully."""
        print("\n\nüí° Tip: Use /exit or Ctrl+D to exit OSA")
        print("üìù Your session is auto-saved\n")
        # Don't exit, just return to prompt
    
    def clear_screen(self):
        """Clear the terminal screen."""
        os.system('clear' if os.name == 'posix' else 'cls')
    
    def print_banner(self):
        """Print OSA banner."""
        self.clear_screen()
        
        if RICH_AVAILABLE:
            banner = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                              ‚ïë
‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà      OSA Terminal v1.0.0         ‚ïë
‚ïë    ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà     OmniMind Super Agent        ‚ïë
‚ïë    ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                                 ‚ïë
‚ïë    ‚ñà‚ñà    ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà     Enhanced AI Assistant       ‚ïë
‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà     Think ‚Ä¢ Learn ‚Ä¢ Create      ‚ïë
‚ïë                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
            """
            console.print(banner, style="bold cyan")
            
            # Print quick info
            info_table = Table(show_header=False, box=None)
            info_table.add_column("", style="dim")
            info_table.add_column("")
            
            info_table.add_row("üìÅ Project:", str(self.current_project))
            info_table.add_row("ü§ñ Model:", self.config['model'])
            info_table.add_row("üí≠ Thinking:", "‚úì" if self.config['enable_thinking'] else "‚úó")
            info_table.add_row("üß† Learning:", "‚úì" if self.config['enable_learning'] else "‚úó")
            
            console.print(info_table)
            console.print()
        else:
            print("="*60)
            print("OSA Terminal v1.0.0 - OmniMind Super Agent")
            print("Think ‚Ä¢ Learn ‚Ä¢ Create")
            print("="*60)
            print(f"üìÅ Project: {self.current_project}")
            print(f"ü§ñ Model: {self.config['model']}")
            print()
        
        print("Type /help for commands, or enter your prompt")
        print("Press Ctrl+D or type /exit to quit\n")
    
    async def initialize_osa(self):
        """Initialize the OSA instance."""
        print("üöÄ Initializing OSA systems...")
        
        try:
            self.osa = OSACompleteFinal(self.config)
            await self.osa.initialize()
            
            if RICH_AVAILABLE:
                console.print("‚úÖ OSA ready!", style="bold green")
            else:
                print("‚úÖ OSA ready!")
            
            return True
        except Exception as e:
            if RICH_AVAILABLE:
                console.print(f"‚ùå Failed to initialize: {e}", style="bold red")
            else:
                print(f"‚ùå Failed to initialize: {e}")
            return False
    
    def get_prompt(self) -> str:
        """Get the command prompt based on context."""
        mode_symbol = {
            "general": "ü§ñ",
            "code": "üíª",
            "thinking": "üí≠",
            "learning": "üß†"
        }.get(self.context_mode, "‚ñ∂")
        
        return f"{mode_symbol} OSA> "
    
    async def process_command(self, command: str) -> bool:
        """
        Process special commands.
        Returns True if command was handled, False otherwise.
        """
        command = command.strip()
        
        if command == "/exit" or command == "/quit":
            return await self.shutdown()
        
        elif command == "/clear":
            self.clear_screen()
            return True
        
        elif command == "/help":
            self.show_help()
            return True
        
        elif command == "/history":
            self.show_history()
            return True
        
        elif command == "/status":
            self.show_status()
            return True
        
        elif command == "/think":
            self.context_mode = "thinking"
            print("üí≠ Entered thinking mode - I'll think deeply about topics")
            return True
        
        elif command == "/code":
            self.context_mode = "code"
            print("üíª Entered code mode - Optimized for programming tasks")
            return True
        
        elif command == "/general":
            self.context_mode = "general"
            print("ü§ñ Entered general mode")
            return True
        
        elif command == "/learn":
            self.context_mode = "learning"
            print("üß† Entered learning mode - I'll learn from our interaction")
            return True
        
        elif command.startswith("/model "):
            new_model = command[7:].strip()
            if new_model:
                self.config['model'] = new_model
                self.save_config()
                print(f"üîÑ Model changed to: {new_model}")
                print("Restart OSA for changes to take effect")
            return True
        
        elif command.startswith("/project "):
            project_path = command[9:].strip()
            if project_path:
                path = Path(project_path).resolve()
                if path.exists():
                    self.current_project = path
                    os.chdir(path)
                    print(f"üìÅ Project context set to: {path}")
                else:
                    print(f"‚ùå Path does not exist: {path}")
            return True
        
        elif command == "/save":
            self.save_session()
            return True
        
        return False
    
    def show_help(self):
        """Show help information."""
        if RICH_AVAILABLE:
            help_text = """
# OSA Commands

## Navigation
- `/help` - Show this help
- `/exit` or `/quit` - Exit OSA
- `/clear` - Clear screen

## Modes
- `/general` - General assistant mode
- `/code` - Code generation mode
- `/think` - Deep thinking mode  
- `/learn` - Learning mode

## Session
- `/history` - Show command history
- `/save` - Save current session
- `/status` - Show OSA status

## Configuration
- `/model <name>` - Change model
- `/project <path>` - Set project context

## Tips
- Use arrow keys to navigate history
- Tab completion available
- Ctrl+C to interrupt current task
- Ctrl+D to exit
"""
            console.print(Markdown(help_text))
        else:
            print("\nOSA Commands:")
            print("-" * 40)
            for cmd, desc in self.config['shortcuts'].items():
                print(f"{cmd:15} - {desc}")
            print()
    
    def show_history(self):
        """Show command history."""
        print("\nüìú Recent History:")
        print("-" * 40)
        
        # Get last 10 items from readline history
        history_length = readline.get_current_history_length()
        start = max(0, history_length - 10)
        
        for i in range(start, history_length):
            item = readline.get_history_item(i + 1)
            if item and not item.startswith('/'):
                print(f"{i+1:4}: {item[:70]}...")
        print()
    
    def show_status(self):
        """Show OSA status."""
        if self.osa:
            status = self.osa.get_status()
            
            if RICH_AVAILABLE:
                table = Table(title="OSA Status", show_header=True)
                table.add_column("Property", style="cyan")
                table.add_column("Value", style="green")
                
                table.add_row("Model", status['model'])
                table.add_row("Thinking", "‚úì" if status['thinking_enabled'] else "‚úó")
                table.add_row("Learning", "‚úì" if status['learning_enabled'] else "‚úó")
                table.add_row("Tasks Processed", str(status['tasks_processed']))
                table.add_row("Thoughts Generated", str(status['thoughts_generated']))
                table.add_row("Session Duration", str(datetime.now() - self.session_start).split('.')[0])
                table.add_row("Ollama Connected", "‚úì" if status['ollama_connected'] else "‚úó")
                
                console.print(table)
            else:
                print("\nüìä OSA Status:")
                print("-" * 40)
                for key, value in status.items():
                    print(f"{key:20}: {value}")
                print(f"Session Duration    : {str(datetime.now() - self.session_start).split('.')[0]}")
            print()
    
    def save_session(self):
        """Save current session."""
        session_data = {
            "timestamp": datetime.now().isoformat(),
            "project": str(self.current_project),
            "model": self.config['model'],
            "command_count": self.command_count,
            "history": session_history[-50:] if session_history else []
        }
        
        with open(SESSION_FILE, 'w') as f:
            json.dump(session_data, f, indent=2)
        
        print(f"üíæ Session saved to {SESSION_FILE}")
    
    async def process_prompt(self, prompt: str):
        """Process a user prompt based on current mode."""
        self.command_count += 1
        session_history.append({
            "prompt": prompt,
            "mode": self.context_mode,
            "timestamp": datetime.now().isoformat()
        })
        
        try:
            # Add mode-specific context
            if self.context_mode == "code":
                enhanced_prompt = f"[Programming Task] {prompt}\nProvide clean, well-commented code with explanations."
            elif self.context_mode == "thinking":
                result = await self.osa.think_about(prompt)
            elif self.context_mode == "learning":
                enhanced_prompt = f"[Learning Mode] {prompt}\nLearn from this and provide comprehensive insights."
                result = await self.osa.accomplish_task(enhanced_prompt)
            else:
                result = await self.osa.accomplish_task(prompt)
            
            # Handle thinking mode specially
            if self.context_mode == "thinking":
                # Already got result from think_about
                pass
            elif self.context_mode != "thinking":
                result = await self.osa.accomplish_task(enhanced_prompt if self.context_mode in ["code", "learning"] else prompt)
            
            # Display result
            if RICH_AVAILABLE:
                # Format based on content type
                if "```" in result:
                    # Contains code blocks
                    console.print(Markdown(result))
                else:
                    # Regular text
                    console.print(Panel(result, title="Response", border_style="green"))
            else:
                print("\n" + "="*60)
                print(result)
                print("="*60 + "\n")
            
            # Save to history
            session_history[-1]["response"] = result[:500]  # Save first 500 chars
            
        except Exception as e:
            if RICH_AVAILABLE:
                console.print(f"‚ùå Error: {e}", style="bold red")
            else:
                print(f"‚ùå Error: {e}")
    
    async def shutdown(self):
        """Shutdown OSA gracefully."""
        print("\nüëã Shutting down OSA...")
        
        if self.config.get("auto_save", True):
            self.save_session()
        
        if self.osa:
            await self.osa.shutdown()
        
        self.save_history()
        self.save_config()
        
        print("‚ú® Thanks for using OSA! Goodbye!")
        self.running = False
        return True
    
    async def run(self):
        """Main run loop."""
        self.print_banner()
        
        # Initialize OSA
        if not await self.initialize_osa():
            return
        
        print()
        
        # Main loop
        while self.running:
            try:
                # Get input
                prompt_text = self.get_prompt()
                
                if RICH_AVAILABLE:
                    user_input = Prompt.ask(prompt_text)
                else:
                    user_input = input(prompt_text)
                
                # Check for empty input
                if not user_input.strip():
                    continue
                
                # Check for commands
                if user_input.startswith('/'):
                    if await self.process_command(user_input):
                        if not self.running:
                            break
                        continue
                
                # Process prompt
                await self.process_prompt(user_input)
                
            except EOFError:
                # Ctrl+D pressed
                await self.shutdown()
                break
            except KeyboardInterrupt:
                # Ctrl+C pressed
                print("\nüí° Use /exit or Ctrl+D to quit")
                continue
            except Exception as e:
                print(f"‚ùå Unexpected error: {e}")
                continue


async def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="OSA - OmniMind Super Agent",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  osa                    # Start interactive mode
  osa --model mistral    # Use different model
  osa --no-thinking      # Disable thinking mode
  osa --project /path    # Set project context
        """
    )
    
    parser.add_argument(
        "--model",
        default=None,
        help="Model to use (e.g., llama3.2:3b, mistral:7b)"
    )
    
    parser.add_argument(
        "--project",
        default=None,
        help="Set project directory context"
    )
    
    parser.add_argument(
        "--no-thinking",
        action="store_true",
        help="Disable continuous thinking"
    )
    
    parser.add_argument(
        "--no-learning",
        action="store_true",
        help="Disable continuous learning"
    )
    
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose output"
    )
    
    parser.add_argument(
        "--version",
        action="version",
        version="OSA 1.0.0"
    )
    
    args = parser.parse_args()
    
    # Create terminal instance
    terminal = OSATerminal()
    
    # Apply command-line arguments
    if args.model:
        terminal.config['model'] = args.model
    
    if args.project:
        project_path = Path(args.project).resolve()
        if project_path.exists():
            terminal.current_project = project_path
            os.chdir(project_path)
    
    if args.no_thinking:
        terminal.config['enable_thinking'] = False
    
    if args.no_learning:
        terminal.config['enable_learning'] = False
    
    if args.verbose:
        terminal.config['verbose'] = True
    
    # Run terminal
    try:
        await terminal.run()
    except Exception as e:
        print(f"Fatal error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nGoodbye!")
        sys.exit(0)