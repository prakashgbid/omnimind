#!/usr/bin/env python3
"""
OSA - OmniMind Super Agent CLI
Professional command-line interface with Claude Code-style formatting.
"""

import os
import sys
import asyncio
import argparse
import json
import readline
import atexit
import textwrap
import shutil
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any, List, Tuple
import subprocess
import signal
from enum import Enum

# Add the src directory to path
SCRIPT_DIR = Path(__file__).resolve().parent
sys.path.insert(0, str(SCRIPT_DIR / "src"))

from core.osa_autonomous import OSAAutonomous, IntentType
from core.logger import setup_logger

# Terminal colors and styles
class Colors:
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    
    # Colors
    BLACK = '\033[30m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    
    # Background
    BG_GRAY = '\033[100m'
    
    # Special
    UNDERLINE = '\033[4m'

# Global OSA instance
osa_instance = None
session_history = []

# Configuration
CONFIG_DIR = Path.home() / ".osa"
CONFIG_FILE = CONFIG_DIR / "config.json"
HISTORY_FILE = CONFIG_DIR / "history.txt"
SESSION_FILE = CONFIG_DIR / "session.json"

class OSATerminal:
    """OSA Terminal with Claude Code-style interface."""
    
    def __init__(self):
        self.osa = None
        self.config = self.load_config()
        self.setup_readline()
        self.running = True
        self.session_start = datetime.now()
        self.command_count = 0
        self.current_project = Path.cwd()
        self.terminal_width = shutil.get_terminal_size().columns
        
        # Setup signal handlers
        signal.signal(signal.SIGINT, self.handle_interrupt)
        
    def load_config(self) -> Dict[str, Any]:
        """Load or create configuration."""
        CONFIG_DIR.mkdir(exist_ok=True)
        
        default_config = {
            "model": "llama3.2:3b",
            "theme": "dark",
            "verbose": False,
            "auto_save": True,
            "enable_thinking": True,
            "enable_learning": True,
            "max_history": 1000,
            "shortcuts": {
                "/help": "Show help",
                "/exit": "Exit OSA",
                "/clear": "Clear screen",
                "/history": "Show history",
                "/save": "Save session",
                "/status": "Show status"
            }
        }
        
        if CONFIG_FILE.exists():
            with open(CONFIG_FILE, 'r') as f:
                config = json.load(f)
                # Merge with defaults
                for key, value in default_config.items():
                    if key not in config:
                        config[key] = value
                return config
        else:
            with open(CONFIG_FILE, 'w') as f:
                json.dump(default_config, f, indent=2)
            return default_config
    
    def save_config(self):
        """Save configuration."""
        with open(CONFIG_FILE, 'w') as f:
            json.dump(self.config, f, indent=2)
    
    def setup_readline(self):
        """Setup readline for better input handling."""
        # Enable tab completion
        readline.parse_and_bind("tab: complete")
        
        # Load history with error handling
        if HISTORY_FILE.exists():
            try:
                readline.read_history_file(str(HISTORY_FILE))
            except (PermissionError, IOError) as e:
                # Create new history file if permission error
                print(f"Note: Could not load history: {e}")
                try:
                    HISTORY_FILE.touch()
                    HISTORY_FILE.chmod(0o600)
                except:
                    pass
        else:
            # Create history file if it doesn't exist
            try:
                HISTORY_FILE.parent.mkdir(parents=True, exist_ok=True)
                HISTORY_FILE.touch()
                HISTORY_FILE.chmod(0o600)
            except:
                pass
        
        # Set history size
        readline.set_history_length(self.config.get("max_history", 1000))
        
        # Save history on exit
        atexit.register(self.save_history)
    
    def save_history(self):
        """Save command history."""
        try:
            readline.write_history_file(str(HISTORY_FILE))
        except (PermissionError, IOError):
            # Silently fail if we can't write history
            pass
    
    def handle_interrupt(self, signum, frame):
        """Handle Ctrl+C gracefully."""
        print(f"\n\n{Colors.YELLOW}!{Colors.RESET} Use 'exit' or Ctrl+D to quit")
        # Don't exit, just return to prompt
    
    def show_thinking(self, message: str = "Thinking..."):
        """Show thinking indicator like Claude Code."""
        print(f"\n{Colors.YELLOW}‚úª{Colors.RESET} {Colors.DIM}{message}{Colors.RESET}", end='', flush=True)
    
    def clear_thinking(self):
        """Clear the thinking line."""
        print('\r' + ' ' * 80 + '\r', end='', flush=True)
    
    def show_tool_call(self, tool_name: str, params: str = ""):
        """Show tool call like Claude Code."""
        print(f"\n{Colors.CYAN}‚è∫{Colors.RESET} {Colors.BOLD}{tool_name}{Colors.RESET}", end='')
        if params:
            print(f"{Colors.DIM}({params}){Colors.RESET}")
        else:
            print()
    
    def show_tool_output(self, output: str, collapsed: bool = True):
        """Show tool output with Claude Code style."""
        lines = output.strip().split('\n')
        width = min(self.terminal_width - 6, 94)
        
        # Connector line
        print(f"  {Colors.DIM}‚éø{Colors.RESET}  ", end='')
        
        if collapsed and len(lines) > 5:
            # Show first 3 lines
            for i, line in enumerate(lines[:3]):
                if i > 0:
                    print("     ", end='')
                if len(line) > width:
                    line = line[:width-3] + "..."
                print(line)
            
            # Show collapse indicator
            remaining = len(lines) - 3
            print(f"     {Colors.DIM}‚Ä¶ +{remaining} lines (ctrl+r to expand){Colors.RESET}")
        else:
            # Show all lines
            for i, line in enumerate(lines):
                if i > 0:
                    print("     ", end='')
                if len(line) > width:
                    wrapped = textwrap.wrap(line, width)
                    print(wrapped[0])
                    for wrap_line in wrapped[1:]:
                        print("     " + wrap_line)
                else:
                    print(line)
    
    def show_error(self, error: str):
        """Show error message."""
        print(f"\n{Colors.RED}‚úó{Colors.RESET} {Colors.BOLD}Error:{Colors.RESET} {error}")
    
    
    def clear_screen(self):
        """Clear the terminal screen."""
        # Use ANSI escape codes instead of system clear
        print('\033[2J\033[H', end='')
    
    def print_banner(self):
        """Print minimal OSA banner."""
        # Don't clear screen, just add some space
        print(f"\n{Colors.BOLD}OSA{Colors.RESET} - Autonomous AI Assistant")
        print(f"{Colors.DIM}I understand what you need automatically{Colors.RESET}\n")
    
    async def initialize_osa(self):
        """Initialize the OSA instance."""
        print(f"{Colors.DIM}Initializing OSA systems...{Colors.RESET}")
        
        try:
            # Suppress debug output
            import logging
            logging.getLogger('OSA-Auto').setLevel(logging.WARNING)
            
            self.osa = OSAAutonomous(self.config)
            await self.osa.initialize()
            print(f"{Colors.GREEN}‚úì{Colors.RESET} OSA ready!\n")
            return True
        except Exception as e:
            self.show_error(f"Failed to initialize: {e}")
            return False
    
    def draw_input_box(self) -> str:
        """Draw a distinct input box like Claude Code."""
        width = min(self.terminal_width - 4, 100)
        
        # Top border
        print(f"{Colors.DIM}‚ï≠{'‚îÄ' * (width - 2)}‚ïÆ{Colors.RESET}")
        
        # Input area with styled prompt - print the left border and prompt
        print(f"{Colors.DIM}‚îÇ{Colors.RESET} {Colors.BOLD}{Colors.CYAN}You{Colors.RESET} ", end='', flush=True)
        
        # Return empty for input() to use
        return ""
    
    def close_input_box(self):
        """Close the input box after input."""
        width = min(self.terminal_width - 4, 100)
        print(f"{Colors.DIM}‚ï∞{'‚îÄ' * (width - 2)}‚ïØ{Colors.RESET}")
    
    async def process_command(self, command: str):
        """
        Process special commands.
        """
        command = command.strip().lower()
        
        if command in ["/exit", "/quit"]:
            await self.shutdown()
            return
        
        elif command == "/clear":
            self.clear_screen()
            self.print_banner()
            return
        
        elif command == "/help":
            self.show_help()
            return
        
        elif command == "/history":
            self.show_history()
            return
        
        elif command == "/status":
            self.show_status()
            return
        
        elif command == "/reset":
            if self.osa:
                self.osa.conversation_context = []
                print(f"{Colors.GREEN}‚úì{Colors.RESET} Conversation context reset\n")
            return
        
        elif command == "/model":
            if self.osa:
                print(f"\n{Colors.CYAN}Current model:{Colors.RESET} {self.osa.model}\n")
            return
        
        elif command == "/version":
            print(f"\n{Colors.CYAN}OSA Version:{Colors.RESET} 3.0 Claude-Style\n")
            return
        
        
        elif command == "/save":
            self.save_session()
            return
        
        else:
            print(f"{Colors.YELLOW}Unknown command:{Colors.RESET} {command}")
            print(f"{Colors.DIM}Type / to see available commands{Colors.RESET}\n")
            return
    
    def show_command_suggestions(self):
        """Show available commands when user types /."""
        print(f"\n{Colors.CYAN}Available commands:{Colors.RESET}")
        print(f"{Colors.DIM}{'‚îÄ' * 40}{Colors.RESET}")
        
        commands = [
            ("/help", "Show detailed help"),
            ("/exit", "Exit OSA"),
            ("/clear", "Clear screen"),
            ("/history", "Show command history"),
            ("/save", "Save current session"),
            ("/status", "Show OSA status"),
            ("/reset", "Reset conversation context"),
            ("/model", "Show current model"),
            ("/version", "Show OSA version")
        ]
        
        for cmd, desc in commands:
            print(f"  {Colors.CYAN}{cmd:12}{Colors.RESET} {Colors.DIM}{desc}{Colors.RESET}")
        
        print(f"\n{Colors.DIM}Or just type naturally and I'll understand!{Colors.RESET}\n")
    
    def show_help(self):
        """Show help information."""
        print(f"\n{Colors.CYAN}OSA Help{Colors.RESET}")
        print(f"{Colors.DIM}{'=' * 60}{Colors.RESET}\n")
        
        sections = [
            ("Navigation", [
                ("/help", "Show this help"),
                ("/exit or /quit", "Exit OSA"),
                ("/clear", "Clear screen")
            ]),
            ("Session", [
                ("/history", "Show command history"),
                ("/save", "Save current session"),
                ("/status", "Show OSA status"),
                ("/reset", "Reset conversation context")
            ]),
            ("Information", [
                ("/model", "Show current model"),
                ("/version", "Show OSA version")
            ]),
            ("Tips", [
                ("Arrow keys", "Navigate history"),
                ("Tab", "Auto-completion"),
                ("Ctrl+C", "Cancel operation"),
                ("Ctrl+D", "Exit OSA")
            ])
        ]
        
        for section_name, items in sections:
            print(f"{Colors.BOLD}{section_name}:{Colors.RESET}")
            for cmd, desc in items:
                print(f"  {Colors.CYAN}{cmd:20}{Colors.RESET} {Colors.DIM}{desc}{Colors.RESET}")
            print()
    
    def show_history(self):
        """Show command history."""
        print("\nüìú Recent History:")
        print("-" * 40)
        
        # Get last 10 items from readline history
        history_length = readline.get_current_history_length()
        start = max(0, history_length - 10)
        
        for i in range(start, history_length):
            item = readline.get_history_item(i + 1)
            if item and not item.startswith('/'):
                print(f"{i+1:4}: {item[:70]}...")
        print()
    
    def show_status(self):
        """Show OSA status."""
        if self.osa:
            status = self.osa.get_status()
            
            print(f"\n{Colors.CYAN}üìä OSA Status{Colors.RESET}")
            print(f"{Colors.DIM}{'‚îÄ' * 40}{Colors.RESET}")
            
            items = [
                ("Model", status['model']),
                ("Conversations", str(status.get('conversations', 0))),
                ("Learning Entries", str(status.get('learning_entries', 0))),
                ("Last Intent", status.get('last_intent', 'None')),
                ("Session Duration", str(datetime.now() - self.session_start).split('.')[0]),
                ("Ollama Connected", "‚úì" if status['ollama_connected'] else "‚úó")
            ]
            
            for key, value in items:
                print(f"  {Colors.BOLD}{key:20}{Colors.RESET} {Colors.GREEN}{value}{Colors.RESET}")
            print()
    
    def save_session(self):
        """Save current session."""
        session_data = {
            "timestamp": datetime.now().isoformat(),
            "model": self.config['model'],
            "command_count": self.command_count,
            "history": session_history[-50:] if session_history else []
        }
        
        with open(SESSION_FILE, 'w') as f:
            json.dump(session_data, f, indent=2)
        
        print(f"üíæ Session saved to {SESSION_FILE}")
    
    async def process_prompt(self, prompt: str):
        """Process a user prompt autonomously."""
        self.command_count += 1
        session_history.append({
            "prompt": prompt,
            "timestamp": datetime.now().isoformat()
        })
        
        try:
            # Check for slash command or suggestions
            if prompt == '/':
                self.show_command_suggestions()
                return
            
            # Check for exit
            if prompt.lower() in ['exit', 'quit', 'bye']:
                await self.shutdown()
                return
            
            # Check for slash commands
            if prompt.startswith('/'):
                await self.process_command(prompt)
                return
            
            # Show thinking
            self.show_thinking("OSA is analyzing your request...")
            
            # Process autonomously - OSA figures out what to do
            result = await self.osa.process_autonomously(prompt)
            
            # Clear thinking
            self.clear_thinking()
            
            # Parse result to extract intent
            lines = result.split('\n\n', 1)
            if len(lines) > 1:
                status_line = lines[0]
                content = lines[1]
                
                # Extract intent type from status
                intent_type = None
                for intent in IntentType:
                    if intent.value.replace('_', ' ').lower() in status_line.lower():
                        intent_type = intent
                        break
                
                # Show response with proper formatting
                if intent_type:
                    emoji = self.get_intent_emoji(intent_type)
                    self.show_tool_call(f"{emoji} {intent_type.value.replace('_', ' ').title()}")
                
                # Show output
                self.show_tool_output(content)
            else:
                # Simple response
                self.show_tool_output(result)
            
            # Save to history
            if session_history:
                session_history[-1]["response"] = result[:500]  # Save first 500 chars
            
        except Exception as e:
            self.clear_thinking()
            self.show_error(str(e))
    
    def get_intent_emoji(self, intent: IntentType) -> str:
        """Get emoji for intent type."""
        emoji_map = {
            IntentType.CODE_GENERATION: "üíª",
            IntentType.CODE_DEBUG: "üêõ",
            IntentType.CODE_REFACTOR: "üîß",
            IntentType.DEEP_THINKING: "üß†",
            IntentType.PROBLEM_SOLVING: "üéØ",
            IntentType.LEARNING: "üìö",
            IntentType.EXPLANATION: "üí°",
            IntentType.CREATIVE: "üé®",
            IntentType.ANALYSIS: "üîç",
            IntentType.GENERAL_CHAT: "üí¨",
            IntentType.SYSTEM_TASK: "‚öôÔ∏è"
        }
        return emoji_map.get(intent, "ü§ñ")
    
    async def shutdown(self):
        """Shutdown OSA gracefully."""
        print(f"\n{Colors.GREEN}‚úì{Colors.RESET} Shutting down OSA...")
        
        if self.config.get("auto_save", True):
            self.save_session()
        
        if self.osa:
            await self.osa.shutdown()
        
        self.save_history()
        self.save_config()
        
        # Show session stats
        duration = datetime.now() - self.session_start
        print(f"\n{Colors.DIM}Session Summary:{Colors.RESET}")
        print(f"  Duration: {str(duration).split('.')[0]}")
        print(f"  Interactions: {self.command_count}")
        
        print(f"\n{Colors.GREEN}‚úì{Colors.RESET} Goodbye!")
        self.running = False
        return True
    
    async def run(self):
        """Main run loop."""
        self.print_banner()
        
        # Initialize OSA
        if not await self.initialize_osa():
            return
        
        print()
        
        # Main loop
        while self.running:
            try:
                # Simple input box
                width = 78
                print(f"{Colors.DIM}‚ï≠{'‚îÄ' * width}‚ïÆ{Colors.RESET}")
                user_input = input(f"{Colors.DIM}‚îÇ{Colors.RESET} {Colors.BOLD}{Colors.CYAN}You:{Colors.RESET} ")
                print(f"{Colors.DIM}‚ï∞{'‚îÄ' * width}‚ïØ{Colors.RESET}")
                
                # Check for empty input
                if not user_input.strip():
                    continue
                
                # Process prompt (handles both commands and natural language)
                await self.process_prompt(user_input)
                
                # Check if should exit
                if not self.running:
                    break
                
            except (KeyboardInterrupt, EOFError):
                # Ctrl+C or Ctrl+D pressed
                await self.shutdown()
                break
            except Exception as e:
                print(f"‚ùå Unexpected error: {e}")
                continue


async def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="OSA - OmniMind Super Agent",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  osa                    # Start interactive mode
  osa --model mistral    # Use different model
  osa --no-thinking      # Disable thinking mode
  osa --project /path    # Set project context
        """
    )
    
    parser.add_argument(
        "--model",
        default=None,
        help="Model to use (e.g., llama3.2:3b, mistral:7b)"
    )
    
    
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose output"
    )
    
    parser.add_argument(
        "--version",
        action="version",
        version="OSA Claude-Style 3.0"
    )
    
    args = parser.parse_args()
    
    # Create terminal instance
    terminal = OSATerminal()
    
    # Apply command-line arguments
    if args.model:
        terminal.config['model'] = args.model
    
    
    if args.verbose:
        terminal.config['verbose'] = True
    
    # Run terminal
    try:
        await terminal.run()
    except Exception as e:
        print(f"Fatal error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nGoodbye!")
        sys.exit(0)